{
    "title": "Structure and Interpretation of Computer Programs, 2nd ed. (1996)",
    "nb_pages": 855,
    "front_cover": "https://m.media-amazon.com/images/I/71BBXQnykuL._SL100_.jpg",
    "id": "SICP",
    "content": [{
        "title": "1 - Building Abstractions with Procedures",
        "start_page": 1,
        "content": [{
            "title": "1.1 - The Elements of Programming",
            "start_page": 6,
            "content": [{
                "id": "1.1.1",
                "title": "1.1.1 - Expressions",
                "start_page": 7
            },{
                "id": "1.1.2",
                "title": "1.1.2 - Naming and the Environment",
                "start_page": 10
            },{
                "id": "1.1.3",
                "title": "1.1.3 - Evaluating Combinations",
                "start_page": 12
            },{
                "id": "1.1.4",
                "title": "1.1.4 - Compound Procedures",
                "start_page": 15
            },{
                "id": "1.1.5",
                "title": "1.1.5 - The Substitution Model for Procedure Application",
                "start_page": 18
            },{
                "id": "1.1.6",
                "title": "1.1.6 - Conditional Expressions and Predicates",
                "start_page": 22
            },{
                "id": "1.1.7",
                "title": "1.1.7 - Example: Square Roots by Newton\"s Method",
                "start_page": 28
            },{
                "id": "1.1.8",
                "title": "1.1.8 - Procedures as Black-Box Abstractions",
                "start_page": 33
            }]
        },{
            "title": "1.2 - Procedures and the Processes They Generate",
            "start_page": 40,
            "content": [{
                "id": "1.2.1",
                "title": "1.2.1 - Linear Recursion and Iteration",
                "start_page": 41
            },{
                "id": "1.2.2",
                "title": "1.2.2 - Tree recursion",
                "start_page": 47
            },{
                "id": "1.2.3",
                "title": "1.2.3 - Orders of Growth",
                "start_page": 54
            },{
                "id": "1.2.4",
                "title": "1.2.4 - Exponentiation",
                "start_page": 57
            },{
                "id": "1.2.5",
                "title": "1.2.5 - Greatest Common Divisors",
                "start_page": 62,
                "search_context": "GCD, Euclid's algorithm, Lam√©'s Theorem"
            },{
                "id": "1.2.6",
                "title": "1.2.6 - Example: Testing for Primality",
                "start_page": 65,
                "search_context": "Fermat test, Fermat's Little theorem, Probabilistic method, Miller-Rabin test (1976, 1980)"
            }]
        },{
            "title": "1.3 - Formulating Abstractions with Higher-Order Procedures",
            "start_page": 74,
            "content": [{
                "id": "1.3.1",
                "title": "1.3.1 - Procedures as Arguments",
                "start_page": 76
            },{
                "id": "1.3.2",
                "title": "1.3.2 - Constructing Procedures using lambda",
                "start_page": 83
            },{
                "id": "1.3.3",
                "title": "1.3.3 - Procedures as General Methods",
                "start_page": 89
            },{
                "id": "1.3.4",
                "title": "1.3.4 - Procedures as Returned Values",
                "start_page": 97
            }]
        }]
    },{
        "title": "2 - Building Abstractions with Data",
        "start_page": 107,
        "content": [{
            "title": "2.1 - Introduction to Data Abstraction",
            "start_page": 112,
            "content": [{
                "id": "2.1.1",
                "title": "2.1.1 - Example: Arithmetic Operations for Rational Numbers",
                "start_page": 113
            },{
                "id": "2.1.2",
                "title": "2.1.2 - Abstraction Barriers",
                "start_page": 118
            },{
                "id": "2.1.3",
                "title": "2.1.3 - What is Meant by Data?",
                "start_page": 122
            },{
                "id": "2.1.4",
                "title": "2.1.4 - Extended Exercice: Interval Arithmetic",
                "start_page": 126
            }]
        },{
            "title": "2.2 - Hierarchical Data and the Closure Property",
            "start_page": 132,
            "content": [{
                "id": "2.2.1",
                "title": "2.2.1 - Representing Sequences",
                "start_page": 134
            },{
                "id": "2.2.2",
                "title": "2.2.2 - Hierarchical Structures",
                "start_page": 147
            },{
                "id": "2.2.3",
                "title": "2.2.3 - Sequences as Conventional Interfaces",
                "start_page": 154
            },{
                "id": "2.2.4",
                "title": "2.2.4 - Example: A Picture Language",
                "start_page": 172
            }]
        },{
            "title": "2.3 - Symbolic Data",
            "start_page": 192,
            "content": [{
                "id": "2.3.1",
                "title": "2.3.1 - Quotation",
                "start_page": 192
            },{
                "id": "2.3.2",
                "title": "2.3.2 - Example: Symbolic Differentiation",
                "start_page": 197
            },{
                "id": "2.3.3",
                "title": "2.3.3 - Example: Representing Sets",
                "start_page": 205
            },{
                "id": "2.3.4",
                "title": "2.3.4 - Example: Huffman Encoding Trees",
                "start_page": 218
            }]
        },{
            "title": "2.4 - Multiple Representation for Abstract Data",
            "start_page": 229,
            "content": [{
                "id": "2.4.1",
                "title": "2.4.1 - Representations for Complex Numbers",
                "start_page": 232
            },{
                "id": "2.4.2",
                "title": "2.4.2 - Tagged data",
                "start_page": 237
            },{
                "id": "2.4.3",
                "title": "2.4.3 - Data-Directed Progamming and Additivity",
                "start_page": 242
            }]
        },{
            "title": "2.5 - Systems with Generic Operations",
            "start_page": 254,
            "content": [{
                "id": "2.5.1",
                "title": "2.5.1 - Generic Arithmetic Operations",
                "start_page": 255
            },{
                "id": "2.5.2",
                "title": "2.5.2 - Combining Data of Different Types",
                "start_page": 262
            },{
                "id": "2.5.3",
                "title": "2.5.3 - Example: Symbolic Algebra",
                "start_page": 274
            }]
        }]
    },{
        "title": "3 - Modularity, Objects, and State",
        "start_page": 294,
        "content": [{
            "title": "3.1 - Assignment and Local State",
            "start_page": 296,
            "content": [{
                "id": "3.1.1",
                "title": "3.1.1 - Local State Variables",
                "start_page": 297
            },{
                "id": "3.1.2",
                "title": "3.1.2 - The Benefits of Introducing Assignment",
                "start_page": 305
            },{
                "id": "3.1.3",
                "title": "3.1.3 - The Costs of Introducing Assignment",
                "start_page": 311
            }]
        },{
            "title": "3.2 - The Environment Model of Evaluation",
            "start_page": 320,
            "content": [{
                "id": "3.2.1",
                "title": "3.2.1 - The Rules for Evaluation",
                "start_page": 322
            },{
                "id": "3.2.2",
                "title": "3.2.2 - Applying Simple Procedures",
                "start_page": 327
            },{
                "id": "3.2.3",
                "title": "3.2.3 - Frames as the Repository of Local State",
                "start_page": 330
            },{
                "id": "3.2.4",
                "title": "3.2.4 - Internel Definitions",
                "start_page": 337
            }]
        },{
            "title": "3.3 - Modeling with Mutable Data",
            "start_page": 341,
            "content": [{
                "id": "3.3.1",
                "title": "3.3.1 - Mutable List Structure",
                "start_page": 342
            },{
                "id": "3.3.2",
                "title": "3.3.2 - Representing Queues",
                "start_page": 353
            },{
                "id": "3.3.3",
                "title": "3.3.3 - Representing Tables",
                "start_page": 360
            },{
                "id": "3.3.4",
                "title": "3.3.4 - A Simulator for Digital Circuits",
                "start_page": 369
            },{
                "id": "3.3.5",
                "title": "3.3.5 - Propagation of Constraints",
                "start_page": 386
            }]
        },{
            "title": "3.4 - Concurrency: Time Is of the Essence",
            "start_page": 401,
            "content": [{
                "id": "3.4.1",
                "title": "3.4.1 - The Nature of Time in Concurrent Systems",
                "start_page": 403
            },{
                "id": "3.4.2",
                "title": "3.4.2 - Mechanisms for Controlling Concurrency",
                "start_page": 410
            }]
        },{
            "title": "3.5 - Streams",
            "start_page": 428,
            "content": [{
                "id": "3.5.1",
                "title": "3.5.1 - Streams Are Delayed Lists",
                "start_page": 430
            },{
                "id": "3.5.2",
                "title": "3.5.2 - Infinite Streams",
                "start_page": 441
            },{
                "id": "3.5.3",
                "title": "3.5.3 - Exploiting the Stream Paradigm",
                "start_page": 453
            },{
                "id": "3.5.4",
                "title": "3.5.4 - Streams and Delayed Evaluation",
                "start_page": 470
            },{
                "id": "3.5.5",
                "title": "3.5.5 - Modularity of Functional Programs and Modularity of Objects",
                "start_page": 479
            }]
        }]
    },{
        "title": "4 - Metalinguistic Abstraction",
        "start_page": 487,
        "content": [{
            "title": "4.1 - The Metacircular Evaluator",
            "start_page": 492,
            "content": [{
                "id": "4.1.1",
                "title": "4.1.1 - The Core of the Evaluator",
                "start_page": 495
            },{
                "id": "4.1.2",
                "title": "4.1.2 - Representing Expressions",
                "start_page": 501
            },{
                "id": "4.1.3",
                "title": "4.1.3 - Evaluator Data Structures",
                "start_page": 512
            },{
                "id": "4.1.4",
                "title": "4.1.4 - Running the Evaluator as a Program",
                "start_page": 518
            },{
                "id": "4.1.5",
                "title": "4.1.5 - Data as Programs",
                "start_page": 522
            },{
                "id": "4.1.6",
                "title": "4.1.6 - Internal Definitions",
                "start_page": 526
            },{
                "id": "4.1.7",
                "title": "4.1.7 - Separating Syntactic Analysis from Execution",
                "start_page": 534
            }]
        },{
            "title": "4.2 - Variations on a Scheme - Lazy Evaluation",
            "start_page": 541,
            "content": [{
                "id": "4.2.1",
                "title": "4.2.1 - Normal Order and Applicative Order",
                "start_page": 542
            },{
                "id": "4.2.2",
                "title": "4.2.2 - An Interpreter with Lazy Evaluation",
                "start_page": 544
            },{
                "id": "4.2.3",
                "title": "4.2.3 - Streams as Lazy Lists",
                "start_page": 555
            }]
        },{
            "title": "4.3 - Variations on a Scheme - Nondeterministic Computing",
            "start_page": 559,
            "content": [{
                "id": "4.3.1",
                "title": "4.3.1 - Amb and Search",
                "start_page": 561
            },{
                "id": "4.3.2",
                "title": "4.3.2 - Examples of Nondeterministic Programs",
                "start_page": 567
            },{
                "id": "4.3.3",
                "title": "4.3.3 - Implementing the amb Evaluator",
                "start_page": 578
            }]
        },{
            "title": "4.4 - Logic Programming",
            "start_page": 594,
            "content": [{
                "id": "4.4.1",
                "title": "4.4.1 - Deductive Information Retrieval",
                "start_page": 599
            },{
                "id": "4.4.2",
                "title": "4.4.2 - How the Query System Works",
                "start_page": 615
            },{
                "id": "4.4.3",
                "title": "4.4.3 - Is Logic Programming Mathematical Logic?",
                "start_page": 627
            },{
                "id": "4.4.4",
                "title": "4.4.4 - Implementing the Query System",
                "start_page": 635,
                "content": [{
                    "id": "4.4.4.1",
                    "title": "4.4.4.1 - The Driver Loop and Instantiation",
                    "start_page": 636
                },{
                    "id": "4.4.4.2",
                    "title": "4.4.4.2 - The Evaluator",
                    "start_page": 638
                },{
                    "id": "4.4.4.3",
                    "title": "4.4.4.3 - Finding Assertions by Pattern Matching",
                    "start_page": 642
                },{
                    "id": "4.4.4.4",
                    "title": "4.4.4.4 - Rules and Unification",
                    "start_page": 645
                },{
                    "id": "4.4.4.5",
                    "title": "4.4.4.5 - Maintaining the Data Base",
                    "start_page": 651
                },{
                    "id": "4.4.4.6",
                    "title": "4.4.4.6 - Stream Operations",
                    "start_page": 654
                },{
                    "id": "4.4.4.7",
                    "title": "4.4.4.7 - Query Syntax Procedures",
                    "start_page": 656
                },{
                    "id": "4.4.4.9",
                    "title": "4.4.4.8 - Frames and Bindings",
                    "start_page": 659
                }]
            }]
        }]
    },{
        "title": "5 - Computing with Register Machines",
        "start_page": 666,
        "content": [{
            "title": "5.1 - Designing Register Machines",
            "start_page": 668,
            "content": [{
                "id": "5.1.1",
                "title": "5.1.1 - A Language for Describing Register Machines",
                "start_page": 672
            },{
                "id": "5.1.2",
                "title": "5.1.2 - Abstraction in Machine Design",
                "start_page": 678
            },{
                "id": "5.1.3",
                "title": "5.1.3 - Subroutines",
                "start_page": 681
            },{
                "id": "5.1.4",
                "title": "5.1.4 - Using a Stack to Implement Recursion",
                "start_page": 686
            },{
                "id": "5.1.5",
                "title": "5.1.5 - Instruction Summary",
                "start_page": 695
            }]
        },{
            "title": "5.2 - A Register-Machine Simulator",
            "start_page": 696,
            "content": [{
                "id": "5.2.1",
                "title": "5.2.1 - The Machine Model",
                "start_page": 698
            },{
                "id": "5.2.2",
                "title": "5.2.2 - The Assembler",
                "start_page": 704
            },{
                "id": "5.2.3",
                "title": "5.2.3 - Generating Execution Procedures for Instructions",
                "start_page": 708
            },{
                "id": "5.2.4",
                "title": "5.2.4 - Monitoring Machine Performance",
                "start_page": 718
            }]
        },{
            "title": "5.3 - Storage Allocation and Garbage Collection",
            "start_page": 723,
            "content": [{
                "id": "5.3.1",
                "title": "5.3.1 - Memory as Vectors",
                "start_page": 724
            },{
                "id": "5.3.2",
                "title": "5.3.2 - Maintaining the Illusion of Infinite Memory",
                "start_page": 731
            }]
        },{
            "title": "5.4 - The Explicit-Control Evaluator",
            "start_page": 741,
            "content": [{
                "id": "5.4.1",
                "title": "5.4.1 - The Core of the Explicit-Control Evaluator",
                "start_page": 743
            },{
                "id": "5.4.2",
                "title": "5.4.2 - Sequence Evaluation and Tail Recursion",
                "start_page": 751
            },{
                "id": "5.4.3",
                "title": "5.4.3 - Conditionals, Assignments, and Definitions",
                "start_page": 756
            },{
                "id": "5.4.4",
                "title": "5.4.4 - Running the Evaluator",
                "start_page": 759
            }]
        },{
            "title": "5.5 - Compilation",
            "start_page": 767,
            "content": [{
                "id": "5.5.1",
                "title": "5.5.1 - Structure of the Compiler",
                "start_page": 772
            },{
                "id": "5.5.2",
                "title": "5.5.2 - Compiling Expressions",
                "start_page": 779
            },{
                "id": "5.5.3",
                "title": "5.5.3 - Compiling Combinations",
                "start_page": 788
            },{
                "id": "5.5.4",
                "title": "5.5.4 - Combining Instruction Sequences",
                "start_page": 797
            },{
                "id": "5.5.5",
                "title": "5.5.5 - An Example of Compiled Code",
                "start_page": 802
            },{
                "id": "5.5.6",
                "title": "5.5.6 - Lexical Addressing",
                "start_page": 817
            },{
                "id": "5.5.7",
                "title": "5.5.7 - Interfacing Compiled Code to the Evaluator",
                "start_page": 823
            }]
        }]
    }]
}